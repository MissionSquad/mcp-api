# Feature: Secure Secret Management

## Context
MCP servers often require sensitive credentials (API keys, passwords, tokens) to function properly. Traditional MCP server implementations store these credentials directly in environment variables, which presents security risks and limits multi-user capabilities. The Secure Secret Management feature addresses these limitations by providing a secure, user-specific way to store and retrieve sensitive credentials.

## Goal
Create a secure, scalable system for managing sensitive credentials that supports multi-user access to MCP servers while maintaining proper isolation and encryption of secrets.

## Implementation Details

### Encryption Technology

The MCP API uses AES-256-GCM (Galois/Counter Mode) for encryption, which provides both confidentiality and authentication:

1. **Key Derivation** - The encryption key is derived from a master key using SHA-256
2. **IV Generation** - A random 12-byte Initialization Vector (IV) is generated for each encryption operation
3. **Authentication** - GCM provides built-in authentication with an authentication tag
4. **Format** - Encrypted data is stored in the format `iv:authTag:ciphertext` (all in hexadecimal)

```typescript
// SecretEncryptor.encrypt
encrypt(plaintext: string): string {
  // Generate a 12-byte IV for AES-GCM (recommended length).
  const iv = crypto.randomBytes(12);
  const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);

  let encrypted = cipher.update(plaintext, 'utf8', 'hex');
  encrypted += cipher.final('hex');

  // Retrieve the authentication tag generated by GCM.
  const authTag = cipher.getAuthTag();

  // Concatenate IV, auth tag, and ciphertext, separated by colons.
  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
}
```

### Secret Storage

Secrets are stored in MongoDB with the following schema:

```typescript
interface UserSecret {
  username: string;
  server: string;
  key: string;
  value: string; // Encrypted value
}
```

This schema ensures that:

1. Each secret is associated with a specific user
2. Secrets are organized by MCP server
3. Each secret has a unique key within its user and server context

### Secret Management API

The MCP API provides endpoints for managing secrets:

#### Setting a Secret

```http
POST /secrets/set
Content-Type: application/json

{
  "username": "user123",
  "serverName": "mcp-github",
  "secretName": "GITHUB_TOKEN",
  "secretValue": "ghp_xxxxxxxxxxxx"
}
```

This endpoint:
1. Encrypts the secret value using AES-256-GCM
2. Stores the encrypted value in MongoDB
3. Associates the secret with the specified user and server

#### Deleting a Secret

```http
POST /secrets/delete
Content-Type: application/json

{
  "username": "user123",
  "serverName": "mcp-github",
  "secretName": "GITHUB_TOKEN"
}
```

This endpoint:
1. Removes the specified secret from MongoDB
2. Ensures that the secret is no longer available for tool calls

### Secret Retrieval and Usage

When a user makes a tool call, the MCP API:

1. Retrieves the user's secrets for the specified server
2. Decrypts the secrets using the system's master key
3. Merges the secrets with the provided arguments
4. Forwards the merged arguments to the MCP server

```typescript
// In MCPService.callTool
const secrets = await this.secrets.getSecrets(username, serverName);
if (secrets[serverName] != null) {
  args = { ...args, ...secrets[serverName] };
  log({ level: 'info', msg: `Secrets applied to tool call - ${serverName}:${methodName} - ${Object.keys(secrets).join(', ')}` });
}
```

This process is transparent to the user and ensures that their secrets are only used for their own requests.

## Security Considerations

### Key Management

The master encryption key is stored in the `SECRETS_KEY` environment variable, not in the database. This ensures that even if the database is compromised, the secrets remain secure as long as the master key is protected.

```typescript
// In env.ts
export const env = {
  // ...
  SECRETS_KEY: process.env.SECRETS_KEY || 'secret',
  // ...
}
```

In production, this key should be:
1. Randomly generated with sufficient entropy
2. Stored securely (e.g., in a dedicated secret management service)
3. Rotated periodically

### User Isolation

Each user's secrets are isolated and only accessible to that user. This ensures that:

1. User A's secrets are never exposed to User B
2. Each user can have different credentials for the same MCP server
3. Users can manage their own secrets without affecting others

### Minimal Exposure

Decrypted secrets are only held in memory temporarily during tool calls. They are never:

1. Logged to console or files
2. Returned in API responses
3. Stored in plaintext anywhere in the system

## Usage Examples

### GitHub Authentication

A user can store their GitHub personal access token:

```http
POST /secrets/set
Content-Type: application/json

{
  "username": "user123",
  "serverName": "mcp-github",
  "secretName": "GITHUB_TOKEN",
  "secretValue": "ghp_xxxxxxxxxxxx"
}
```

Then use GitHub API tools without including the token in each request:

```http
POST /mcp/tool/call
Content-Type: application/json

{
  "username": "user123",
  "serverName": "mcp-github",
  "methodName": "create_issue",
  "args": {
    "owner": "username",
    "repo": "repo-name",
    "title": "Issue title",
    "body": "Issue description"
  }
}
```

The MCP API will automatically inject the `GITHUB_TOKEN` into the request.

### Multiple API Keys

A user can store multiple API keys for different services:

```http
POST /secrets/set
Content-Type: application/json

{
  "username": "user123",
  "serverName": "mcp-openai",
  "secretName": "OPENAI_API_KEY",
  "secretValue": "sk-xxxxxxxxxxxx"
}
```

```http
POST /secrets/set
Content-Type: application/json

{
  "username": "user123",
  "serverName": "mcp-weather",
  "secretName": "WEATHER_API_KEY",
  "secretValue": "xxxxxxxxxxxx"
}
```

Each key will only be used with its respective MCP server.

## Considerations/Open Questions

- Should we implement key rotation for enhanced security?
- How to handle master key backup and recovery?
- Should we implement a more robust authentication system?
- How to handle secret sharing between users (if needed)?

## AI Assistance Notes
- Model Used: Claude 3 Opus
- Prompt: Nexus System onboarding for MCP API project
- Date Generated: 2025-03-23

## Related Nexus Documents
- [System Overview](../architecture/system_overview.md)
- [Secret Management Architecture](../architecture/secret_management.md)
- [Multi-user Support Feature](./multi_user_support.md)
- [Decision: Secure Secret Management](../decisions/decision_log.md)
