import * as crypto from 'crypto'

export class SecretEncryptor {
  private key: Buffer
  private readonly algorithm = 'aes-256-gcm'

  /**
   * Constructs a new SecretEncryptor.
   * @param key A 32-byte Buffer or a passphrase string (which will be hashed via SHA-256).
   */
  constructor(key: Buffer | string) {
    if (typeof key === 'string') {
      // Note: For a passphrase, consider a proper KDF (e.g., PBKDF2, scrypt) with a salt.
      this.key = crypto.createHash('sha256').update(key).digest()
    } else {
      if (key.length !== 32) {
        throw new Error('Key must be 32 bytes long for AES-256-GCM.')
      }
      this.key = key
    }
  }

  /**
   * Encrypts a plaintext string.
   * @param plaintext The data to encrypt.
   * @returns A string in the format "iv:authTag:ciphertext", all in hexadecimal.
   */
  encrypt(plaintext: string): string {
    // Generate a 12-byte IV for AES-GCM (recommended length).
    const iv = crypto.randomBytes(12)
    const cipher = crypto.createCipheriv(this.algorithm, this.key, iv)

    let encrypted = cipher.update(plaintext, 'utf8', 'hex')
    encrypted += cipher.final('hex')

    // Retrieve the authentication tag generated by GCM.
    const authTag = cipher.getAuthTag()

    // Concatenate IV, auth tag, and ciphertext, separated by colons.
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`
  }

  /**
   * Decrypts data that was encrypted using the encrypt method.
   * @param data A string in the format "iv:authTag:ciphertext".
   * @returns The decrypted plaintext.
   */
  decrypt(data: string): string {
    const parts = data.split(':')
    if (parts.length !== 3) {
      throw new Error('Invalid encrypted data format.')
    }

    const iv = Buffer.from(parts[0], 'hex')
    const authTag = Buffer.from(parts[1], 'hex')
    const encryptedText = parts[2]

    const decipher = crypto.createDecipheriv(this.algorithm, this.key, iv)
    decipher.setAuthTag(authTag)

    let decrypted = decipher.update(encryptedText, 'hex', 'utf8')
    decrypted += decipher.final('utf8')

    return decrypted
  }
}
